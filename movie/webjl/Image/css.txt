3.HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
1. 拖拽释放(Drag and drop) API 
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search  
9. 新的技术webworker, websocket, Geolocation


居中布局 http://www.cnblogs.com/haoyijing/p/5815394.html#css1

CSS3新特性：
新增各种CSS选择器   (: not(.input): 所有class不是“input”的节点）
圆角border-radiuis
多列布局：multi-column layout
阴影和反射： multi-column layout
文字特效：text-shadow・
线性渐变： gradient
旋转：transform
缩放，定位，倾斜，动画，多背景：transform: \scale(0.85,0.90) \ translate(0px, -30px) \ skew(-9deg, 0deg) \ Animation


Css Hack
1.一般是针对IE浏览器处理<!--[if IE]>这段文字只在IE浏览器显示<![endif]-->
2.类内属性前缀法  * + -

4.你如何对网站的文件和资源进行优化？
期待的解决方案包括：
1. 文件合并
2. 文件最小化/文件压缩
3. 使用 CDN 托管
4. 缓存的使用（多个域名来提供缓存）

1. 减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器
2. 前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
3. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能
4. 当需要设置的样式很多时设置 className 而不是直接操作 style
5. 少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作
6. 避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)
7. 图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳

CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

如何解决跨域问题?
1. jsonp（jsonp 的原理是动态插入 script 标签）
2. document.domain + iframe
3. window.name、window.postMessage
4. 服务器上设置代理页面
5. CORS  http://www.ruanyifeng.com/blog/2016/04/cors.html

请解释一下 JavaScript 的同源策略。
概念：
同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。其目的是防止某个文档或脚本从多个不同源装载。
这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。


BFC指的是Block Formatting Context, 它提供了一个环境, html元素在这个环境中按照一定规则进行布局. 一个环境中的元素不会影响到其他环
境中的布局. 决定了元素如何对其内容进行定位, 以及和其他元素的关系和相互作用.
其中: FC(Formatting Context): 指的是页面中的一个渲染区域, 并且拥有一套渲染规则, 它决定了其子元素如何定位, 以及与其他元素的相互
关系和作用.
BFC: 块级格式化上下文, 指的是一个独立的块级渲染区域, 只有block-level box参与, 该区域拥有一套渲染规则来约束块级盒子的布局,
 且与区域外部无关.
?BFC的生成: ?根元素
?float的值不为none
?overflow的值不为visible
?display的值为 inline-block, table-cell, table-caption
?position的值为absolute或fixed
?BFC的约束规则 ?生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。
?生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），
除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。
?分解:
??内部的Box会在垂直方向上一个接一个的放置
?垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。）
?每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，
而position为absolute的元素可以超出他的包含块边界）
?BFC的区域不会与float的元素区域重叠
?计算BFC的高度时，浮动子元素也参与计算
?BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然
?BFC在布局中的应用 ?不和浮动元素重叠: ?如果一个浮动元素后面跟着一个非浮动元素, 就会产生覆盖
?防止margin重叠: ?同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode
?解决浮动相关问题 ?父元素: overflow:hidden    IE: zoom:1(hasLayout)
?根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。实际上只要让父元素生成BFC即可，并不只有这两种方式。
?多栏布局 ?比如左右两栏宽度固定, 中间栏自适应 则中间栏设置 overflow:hidden生成BFC




13.闭包
	闭包是指有权访问另一个函数作用域中的变量函数
	作用：
	1.闭包可以创建私有变量。
	2.模仿块级作用域
	3.缓存, 可保留函数内部的值

GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符（参数在url中，不安全，数据量小，ASCII码）
POST：一般用于修改服务器上的资源，对所发送的信息没有限制（参数在数据体中，安全，数据量大即上传只能用POST，支持整个ＩＳＯ１０６４６字符集）


HTTP状态码
100 Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200 OK   正常返回信息
201 Created  请求成功并且服务器创建了新的资源
202 Accepted  服务器已接受请求，但尚未处理
206――服务器已经完成了部分用户的GET请求
301 Moved Permanently  请求的网页已永久移动到新位置
302 Found  临时性重定向
303 See Other  临时性重定向，且总是使用 GET 请求新的 URI
304 Not Modified  自从上次请求后，请求的网页未修改过
400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
401 Unauthorized  请求未授权
403 Forbidden  禁止访问
404 Not Found  找不到如何与 URI 相匹配的资源
500 Internal Server Error  最常见的服务器端错误
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）


语义化的理解？
根据内容的结构（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
?为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
?用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
?有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重
?方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
?便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
怎么做？
?尽可能少的使用无语义的标签div和span；
?在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；
?不要使用纯样式标签，如：b、font、u等，改用css设置。
?需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；
?使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
?表单域要用fieldset标签包起来，并用legend标签说明表单的用途；
?每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。




请描述一下 cookies，session,sessionStorage 和 localStorage 的区别？

cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
session数据主要存储在服务器上，cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用COOKIe

sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
存储大小：
    cookie数据大小不能超过4k。
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
有期时间：
    localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
    sessionStorage  数据在当前浏览器窗口关闭后自动删除。
    cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会
sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；


同步编程和异步编程的优缺点

同步的代码, 在很多情况下, CPU其实是在等待中度过的, 比如等待一个网络连接, 等待MySQL服务器的数据返回异步的代码,
就是把这些等待的时间给充分利用起来了, 把网络连接, 访问数据库这种耗时的工作时都在注册一个callback或者event之后切换出来, 
让CPU先去干别的活(例如响应别的请求), 当网络连接,数据库返回结果时再回来执行刚才的callback中的代码
异步的代码可以大大的提升系统的容量上限, 因为充分利用了空闲的CPU时间, 
但是对于单个的请求的性能提升帮助比较有限 (除非你的单个请求大量依赖这种IO操作)


position的值， relative和absolute定位原点是？
absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。
relative生成相对定位的元素，相对于其正常位置进行定位。
static默认值。没有定位，元素出现在正常的流中
inherit规定从父元素继承 position 属性的值。


canvas和svg的区别?
svg:  
?SVG是一种使用XML描述2D图形的语言
?SVG基于XML, 这意味着SVG DOM中的每个元素都是可用的. 所以可以为每个元素附加JavaScript事件处理器
?在SVG中, 每个被绘制的图像均被视为对象. 如果SVG对象的属性发生变化, 那么浏览器能够自动重现图像
Canvas 
?Canvas通过js来绘制2D图形
?Canvas是逐像素进行渲染的
?在Canvas中, 一旦图形被绘制完成, 它就不会继续得到浏览器的关注. 如果其位置发生变化, 那么整个场景也需要重新绘制, 包括任何或许已被图形覆盖的对象.
?区别 
?Canvas支持分辨率, SVG不支持
?Canvas不支持事件处理器, SVG支持
?Canvas只有弱的文本渲染能力, 而SVG最适合带有大型渲染区域的应用程序(比如谷歌地图)
?Canvas能够以.png或.jpg格式保存结果图像
?SVG的复杂度过高的话会减慢渲染速度(任何过度使用DOM的应用都不快)
?Canvas最适合图像密集型的游戏, 其中的许多对象会被频繁重绘. 而SVG不适合游戏应用
?Canvas是基于位图的图像,它不能够改变大小, 只能缩放显示; SVG是基于矢量的, 所以它能够很好地处理图形大小的改变　　　　
?Canvas提供的功能更原始, 适合像素处理, 动态渲染和大数据量绘制; SVG功能更完善, 适合静态图片显示, 高保真文档查看和打印的应用场景
?绘制Canvas对象后, 不能使用脚本和CSS对它进行修改; 而SVG对象是文档对象模型的一部分, 所以可以随时使用脚本和CSS修改它们


